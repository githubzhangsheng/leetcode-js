/*
剑指 Offer 19. 正则表达式匹配
请实现一个函数用来匹配包含'. '和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab*ac*a"匹配，但与"aa.a"和"ab*a"均不匹配。

示例 1:

输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。
示例 2:

输入:
s = "aa"
p = "a*"
输出: true
解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。
示例 3:

输入:
s = "ab"
p = ".*"
输出: true
解释: ".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。
示例 4:

输入:
s = "aab"
p = "c*a*b"
输出: true
解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。
示例 5:

输入:
s = "mississippi"
p = "mis*is*p*."
输出: false
s 可能为空，且只包含从 a-z 的小写字母。
p 可能为空，且只包含从 a-z 的小写字母以及字符 . 和 *，无连续的 '*'。

https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/
*/ 

/**
 * 思路：动态规划
 * 设主串为A，模式串为B，从最后一步出发，有三种情况：
 * 1. B 的最后一个字符是正常字符，判断 A[n-1] 是否等于 B[m-1]
 * 2. B 的最后一个字符是 ., 它能匹配任意字符，直接查看 A0..n-2 和 B0..m-2
 * 3. B 的最后一个字符是 *, 它代表 B[m-2] = c 可以重复匹配 0 次或者多次，它们是一个整体 c*
 * 情况1：A[n-1] 是 0 个 c，B 的最后两个字符作废，能否匹配取决于 A0..n-1 和 B0..m-3 是否匹配
 * 情况2：A[n-1] 是 多个 c 中的最后一个所以 A 匹配完往前挪一个，B 继续匹配，因为可以匹配多个，继续看 A0..n-2 and B0..m−1是否匹配。
 * 
 * 状态转移方程： 
 * - 对于前面两种情况，可以合并成一种情况 f[i][j] = f[i-1][j-1]
 * - 对于第三种情况，对于 c* 分清看和不看两种情况
 * - - 不看：f[i][j] = f[i][j-2] 看：f[i][j] = f[i-1][j]
 * 
 * 
 * 初始条件：
 * - 空串和空正则是匹配的，f[0][0] = true
 * - 空串和非空正则，需要进行计算
 * - 非空串和空正则，一定不匹配，f[1][0] = ... = f[n][0] = false
 * - 非空串和非空正则，需要进行计算
 */

/**
 * @param {string} s
 * @param {string} p
 * @return {boolean}
 */
 var isMatch = function(s, p) {
    let slen = s.length
    let plen = p.length

    let dp = new Array(slen + 1)
    for(let i = 0; i <= slen; i++) {
        dp[i] = new Array(plen + 1).fill(0)
    }

    for(let i = 0; i <= slen; i++) {
        for(let j = 0; j <= plen; j++) {
            // 区分正则串为空和不为空的情况
            if(j == 0) {
                // 只有当主串为空的时候，空正则串才匹配成功，其它情况均匹配失败，相当于做了一个初始化
                dp[i][j] = i === 0
            } else {
                // 正则串区分 * 和 非 * 的情况
                if(p[j-1] == '*') {
                    // 当前串为 '*' 的情况
                    // 不看 * 
                    if(j >= 2) {
                        dp[i][j] |= dp[i][j-2]
                    } 
                    // 看 *
                    if(j >= 2 && i >= 1 && (s[i-1] == p[j-2] || p[j-2] == '.') ) {
                        dp[i][j] |= dp[i-1][j]
                    }

                } else {
                    // 当前字符为 '.' 或者为正常字符且正则串字符和字符串字符相等，i > 0 预防数组越界的情况
                    // 注意，dp[i][j] 即为当前字符，即 p[i-1] s[j-1] 是否匹配成立的结果1 或者 0 
                    if(i > 0 && (p[j-1] == '.' || p[j-1] == s[i-1] )) {
                        dp[i][j] = dp[i-1][j-1]
                    }
                }

            }

        }
    }
    return dp[slen][plen]
};